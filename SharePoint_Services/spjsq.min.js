/* SP.JS CAML QUERY BUILDER 1.0.0 */
/* https://github.com/usaalex/SharePoint */
/* © WM-FDH, 2016 */ 
var SPJS = SPJS || {}; SPJS.Query = function () { "use strict"; function e(e) { var t = "Text"; return "string" == typeof e && (t = "Text"), "number" == typeof e && (t = "Number"), "boolean" == typeof e && (t = "Boolean"), "object" == typeof e && e instanceof Date && (t = "DateTime"), t } function t(e) { if (0 === O.length && 3 > e) throw new Error("Comparison operator expected."); if (O[O.length - 1] && O[O.length - 1].elementType < 3 && 3 > e) throw new Error("Comparison operator expected."); if (O[O.length - 1] && O[O.length - 1].elementType > 2 && e > 2) throw new Error("Logical join operator expected.") } function n(e, n, r, l, a) { return t(e), "boolean" == typeof l && l && (l = "Lookup"), a && "Lookup" != l && (a = !1), O.push(new A(e, n, r, l, a)), this } function r() { return n.call(this, x.and) } function l() { return n.call(this, x.or) } function a(e, t, r, l) { return n.call(this, x.eq, e, t, r, l) } function i(e, t, r, l) { return n.call(this, x.neq, e, t, r, l) } function o(e, t, r, l) { return n.call(this, x.gt, e, t, r, l) } function u(e, t, r, l) { return n.call(this, x.geq, e, t, r, l) } function c(e, t, r, l) { return n.call(this, x.lt, e, t, r, l) } function s(e, t, r, l) { return n.call(this, x.leq, e, t, r, l) } function p(e, t, r, l) { return n.call(this, x.begins, e, t, r, l) } function f(e, t, r, l) { return n.call(this, x.contains, e, t, r, l) } function h(e, t, r, l) { if (!t || t && (!(t instanceof Array) || t.length <= 0)) throw new Error("Values must be an array and have at least one element."); return n.call(this, x.in_, e, t, r, l) } function d(e, t) { return n.call(this, x.isNull, e) } function m(e, t) { return n.call(this, x.isNotNull, e) } function g(e, t) { var t = t ? "TRUE" : "FALSE"; return V = '<GroupBy Collapse = "' + t + '"><FieldRef Name = "' + e + '"/></GroupBy>', this } function y(e, t) { var n = t ? "FALSE" : "TRUE"; return R += '<FieldRef Name="' + e + '" Ascending="' + n + '" />', this } function v(e) { return B = +e || 0, this } function N(e) { return G = e, this } function T() { for (var e = "", t = 0; t < arguments.length; t++) "string" == typeof arguments[t] && (e += '<FieldRef Name="' + arguments[t] + '" />'); return U = e, this } function q() { var e = "{caml}"; 0 === O.length && (e = ""); for (var t = 0; t < O.length; t++) switch (O[t].elementType) { case x.and: e = "<And>{caml}{caml}</And>".replace("{caml}", e); break; case x.or: e = "<Or>{caml}{caml}</Or>".replace("{caml}", e); break; case x.eq: e = e.replace("{caml}", "<Eq>" + w(O[t]) + "</Eq>"); break; case x.neq: e = e.replace("{caml}", "<Neq>" + w(O[t]) + "</Neq>"); break; case x.gt: e = e.replace("{caml}", "<Gt>" + w(O[t]) + "</Gt>"); break; case x.geq: e = e.replace("{caml}", "<Geq>" + w(O[t]) + "</Geq>"); break; case x.lt: e = e.replace("{caml}", "<Lt>" + w(O[t]) + "</Lt>"); break; case x.leq: e = e.replace("{caml}", "<Leq>" + w(O[t]) + "</Leq>"); break; case x.begins: e = e.replace("{caml}", "<BeginsWith>" + w(O[t]) + "</BeginsWith>"); break; case x.contains: e = e.replace("{caml}", "<Contains>" + w(O[t]) + "</Contains>"); break; case x.includes: e = e.replace("{caml}", "<Includes>" + w(O[t]) + "</Includes>"); break; case x.notIncludes: e = e.replace("{caml}", "<NotIncludes>" + w(O[t]) + "</NotIncludes>"); break; case x.isNull: e = e.replace("{caml}", '<IsNull><FieldRef Name="' + O[t].field + '" /></IsNull>'); break; case x.isNotNull: e = e.replace("{caml}", '<IsNotNull><FieldRef Name="' + O[t].field + '" /></IsNotNull>'); break; case x.in_: e = e.replace("{caml}", "<In>" + C(O[t]) + "</In>") } return "<Where>" + e + "</Where>" } function w(e) { var t = ""; return t = '<FieldRef Name="' + e.field + '" ' + (e.lookupId ? 'LookupId="TRUE"' : "") + ' /><Value Type="' + e.valueType + '">' + e.value + "</Value>" } function I(e, t, n) { var r = "<Query>{where}{order}{group}</Query>".replace("{where}", e || "").replace("{order}", t || "").replace("{group}", n || ""); return r } function b(e, t, n, r) { var l = "<View {scope}>{query}{rowlimit}{fields}</View>".replace("{query}", e || "").replace("{scope}", n || "").replace("{rowlimit}", t || "").replace("{fields}", r || ""); return l } function k(e) { var t = ""; return e > 0 && (t = "<RowLimit>{rowlimit}</RowLimit>".replace("{rowlimit}", e)), t } function L(e) { var t = ""; return e && (t = "<OrderBy>" + e + "</OrderBy>"), t } function S(e) { var t = ""; return e && (t = e), t } function C(e) { var t = "", n = ""; t = '<FieldRef Name="' + e.field + '" ' + (e.lookupId ? 'LookupId="TRUE"' : "") + " /><Values>{values}</Values>"; for (var r = 0; r < e.value.length; r++) n += '<Value Type="' + e.valueType + '">' + e.value[r] + "</Value>"; return t.replace("{values}", n) } function E(e) { var t = ""; return e && (t = "<ViewFields>{fields}</ViewFields>".replace("{fields}", e)), t } function F() { if (O[O.length - 1] && O[O.length - 1].elementType < 3) throw new Error("Comparison operator expected."); var e = q(), t = L(R), n = S(V), r = I(e, t, n), l = k(B), a = E(U), i = b(r, l, G, a); return i } var R = "", V = "", U = "", B = 0, G = "", O = [], x = { and: 1, or: 2, eq: 3, neq: 4, gt: 5, geq: 6, lt: 7, leq: 8, begins: 9, contains: 10, in_: 11, includes: 12, isNull: 13, isNotNull: 14, notIncludes: 15 }; Date.prototype.toISOString || !function () { function e(e) { return 10 > e ? "0" + e : e } Date.prototype.toISOString = function () { return this.getUTCFullYear() + "-" + e(this.getUTCMonth() + 1) + "-" + e(this.getUTCDate()) + "T" + e(this.getUTCHours()) + ":" + e(this.getUTCMinutes()) + ":" + e(this.getUTCSeconds()) + "." + (this.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z" } }(); var A = function (t, n, r, l, a) { this.elementType = t || 0, this.field = n || "", this.value = r || "", this.valueType = l || "", this.lookupId = !!a, n && "undefined" != typeof r && "undefined" == typeof l && (this.valueType = e(r)), n && "undefined" != typeof r && r instanceof Date && (this.value = r.toISOString()), "ID" === n && (this.valueType = "Counter"), a && (this.valueType = "Lookup"), "Lookup" == l && "undefined" == typeof a && (this.lookupId = !0) }; return { And: r, Or: l, Eq: a, Neq: i, Gt: o, Geq: u, Lt: c, Leq: s, BeginsWith: p, Contains: f, In: h, IsNull: d, IsNotNull: m, GroupBy: g, OrderBy: y, Scope: N, RowLimit: v, ViewFields: T, build: F } };