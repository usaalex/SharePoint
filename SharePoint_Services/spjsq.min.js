/* SP.JS CAML QUERY BUILDER 1.0.2 */
/* https://github.com/usaalex/SharePoint */
/* © WM-FDH, 2016 */
var SPJS = SPJS || {}; SPJS.Query = function () { "use strict"; function e(e) { this.name = "ArgumentNullException", this.message = "Value can not be null or undefined. Parameter name: " + e, this.stack = (new Error).stack } function t(e, t) { this.name = "ArgumentException", this.message = (t || "Argument exception") + ". Parameter name: " + e, this.stack = (new Error).stack } function n(e) { return "undefined" == typeof e || null === e || "" === e } function r(e) { return "undefined" != typeof e && e instanceof Array ? !e.length : !0 } function l(e) { var t = "Text"; return "string" == typeof e && (t = "Text"), "number" == typeof e && (t = "Number"), "boolean" == typeof e && (t = "Boolean"), "object" == typeof e && e instanceof Date && (t = "DateTime"), t } function i(e) { if (0 === M.length && 3 > e) throw new Error("Comparison operator expected."); if (M[M.length - 1] && M[M.length - 1].elementType < 3 && 3 > e) throw new Error("Comparison operator expected."); if (M[M.length - 1] && M[M.length - 1].elementType > 2 && e > 2) throw new Error("Logical join operator expected.") } function a(t, r, l, a, o) { if (t >= 3) { if (n(r)) throw new e("fieldName"); if (n(l)) throw new e("value") } i(t); var u = !1; return "boolean" == typeof a ? (u = !!a, a = t == P.in_ ? u ? "Integer" : "Text" : o ? "LookupMulti" : "Lookup") : ("Lookup" === a || "LookupMulti" == a) && (u = !!o, t == P.in_ && (a = u ? "Integer" : "Text")), M.push(new W(t, r, l, a, u)), this } function o() { return a.call(this, P.and) } function u() { return a.call(this, P.or) } function c(e, t, n, r) { return a.call(this, P.eq, e, t, n, r) } function s(e, t, n, r) { return a.call(this, P.neq, e, t, n, r) } function f(e, t, n, r) { return a.call(this, P.gt, e, t, n, r) } function p(e, t, n, r) { return a.call(this, P.geq, e, t, n, r) } function h(e, t, n, r) { return a.call(this, P.lt, e, t, n, r) } function d(e, t, n, r) { return a.call(this, P.leq, e, t, n, r) } function m(e, t, n, r) { return a.call(this, P.begins, e, t, n, r) } function g(e, t, n, r) { return a.call(this, P.contains, e, t, n, r) } function w(e, l, i, o) { if (n(l) || r(l)) throw new t("values", "Value must be an array and have at least one element."); return a.call(this, P.in_, e, l, i, o) } function y(e, t) { return a.call(this, P.isNull, e) } function v(e, t) { return a.call(this, P.isNotNull, e) } function N(t, r) { if (n(t)) throw new e("fieldName"); var r = r ? "TRUE" : "FALSE"; return B = '<GroupBy Collapse = "' + r + '"><FieldRef Name = "' + t + '"/></GroupBy>', this } function T(t, r) { if (n(t)) throw new e("fieldName"); var l = r ? "FALSE" : "TRUE"; return A += '<FieldRef Name="' + t + '" Ascending="' + l + '" />', this } function k(t) { if (n(t) || isNaN(t)) throw new e("num"); return O = +t || 0, this } function I(t) { if (n(t)) throw new e("viewScope"); return D = t, this } function q() { for (var e = "", t = 0; t < arguments.length; t++) "string" == typeof arguments[t] && (e += '<FieldRef Name="' + arguments[t] + '" />'); return G = e, this } function b() { var e = "{caml}"; 0 === M.length && (e = ""); for (var t = 0; t < M.length; t++) switch (M[t].elementType) { case P.and: e = "<And>{caml}{caml}</And>".replace("{caml}", e); break; case P.or: e = "<Or>{caml}{caml}</Or>".replace("{caml}", e); break; case P.eq: e = e.replace("{caml}", "<Eq>" + L(M[t]) + "</Eq>"); break; case P.neq: e = e.replace("{caml}", "<Neq>" + L(M[t]) + "</Neq>"); break; case P.gt: e = e.replace("{caml}", "<Gt>" + L(M[t]) + "</Gt>"); break; case P.geq: e = e.replace("{caml}", "<Geq>" + L(M[t]) + "</Geq>"); break; case P.lt: e = e.replace("{caml}", "<Lt>" + L(M[t]) + "</Lt>"); break; case P.leq: e = e.replace("{caml}", "<Leq>" + L(M[t]) + "</Leq>"); break; case P.begins: e = e.replace("{caml}", "<BeginsWith>" + L(M[t]) + "</BeginsWith>"); break; case P.contains: e = e.replace("{caml}", "<Contains>" + L(M[t]) + "</Contains>"); break; case P.includes: e = e.replace("{caml}", "<Includes>" + L(M[t]) + "</Includes>"); break; case P.notIncludes: e = e.replace("{caml}", "<NotIncludes>" + L(M[t]) + "</NotIncludes>"); break; case P.isNull: e = e.replace("{caml}", '<IsNull><FieldRef Name="' + M[t].field + '" /></IsNull>'); break; case P.isNotNull: e = e.replace("{caml}", '<IsNotNull><FieldRef Name="' + M[t].field + '" /></IsNotNull>'); break; case P.in_: e = e.replace("{caml}", "<In>" + V(M[t]) + "</In>") } return "<Where>" + e + "</Where>" } function L(e) { var t = "", n = ""; return n += "DateTime" === e.valueType ? 'IncludeTimeValue="TRUE"' : "", t = '<FieldRef Name="' + e.field + '" ' + (e.lookupId ? 'LookupId="TRUE"' : "") + " /><Value " + n + ' Type="' + e.valueType + '">' + e.value + "</Value>" } function E(e, t, n) { var r = "<Query>{where}{order}{group}</Query>".replace("{where}", e || "").replace("{order}", t || "").replace("{group}", n || ""); return r } function S(e, t, n, r) { var l = "<View {scope}>{query}{rowlimit}{fields}</View>".replace("{query}", e || "").replace("{scope}", n || "").replace("{rowlimit}", t || "").replace("{fields}", r || ""); return l } function C(e) { var t = ""; return e > 0 && (t = "<RowLimit>{rowlimit}</RowLimit>".replace("{rowlimit}", e)), t } function R(e) { var t = ""; return e && (t = "<OrderBy>" + e + "</OrderBy>"), t } function F(e) { var t = ""; return e && (t = e), t } function V(e) { var t = "", n = ""; t = '<FieldRef Name="' + e.field + '" ' + (e.lookupId ? 'LookupId="TRUE"' : "") + " /><Values>{values}</Values>"; for (var r = 0; r < e.value.length; r++) n += '<Value Type="' + e.valueType + '">' + e.value[r] + "</Value>"; return t.replace("{values}", n) } function x(e) { var t = ""; return e && (t = "<ViewFields>{fields}</ViewFields>".replace("{fields}", e)), t } function U() { if (M[M.length - 1] && M[M.length - 1].elementType < 3) throw new Error("Comparison operator expected."); var e = b(), t = R(A), n = F(B), r = E(e, t, n), l = C(O), i = x(G), a = S(r, l, D, i); return a } var A = "", B = "", G = "", O = 0, D = "", M = [], P = { and: 1, or: 2, eq: 3, neq: 4, gt: 5, geq: 6, lt: 7, leq: 8, begins: 9, contains: 10, in_: 11, includes: 12, isNull: 13, isNotNull: 14, notIncludes: 15 }; Date.prototype.toISOString || !function () { function e(e) { return 10 > e ? "0" + e : e } Date.prototype.toISOString = function () { return this.getUTCFullYear() + "-" + e(this.getUTCMonth() + 1) + "-" + e(this.getUTCDate()) + "T" + e(this.getUTCHours()) + ":" + e(this.getUTCMinutes()) + ":" + e(this.getUTCSeconds()) + "." + (this.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z" } }(); var W = function (e, t, n, r, i) { this.elementType = e || 0, this.field = t || "", this.value = n || "", this.valueType = r || "", this.lookupId = !!i, t && "undefined" != typeof n && "undefined" == typeof r && (this.valueType = l(n)), t && "undefined" != typeof n && n instanceof Date && (this.value = n.toISOString()), "ID" === t && (this.valueType = "Counter"), "Lookup" != r && "LookupMulti" != r || "undefined" != typeof i || (this.lookupId = !0) }; return { And: o, Or: u, Eq: c, Neq: s, Gt: f, Geq: p, Lt: h, Leq: d, BeginsWith: m, Contains: g, In: w, IsNull: y, IsNotNull: v, GroupBy: N, OrderBy: T, Scope: I, RowLimit: k, ViewFields: q, build: U } };