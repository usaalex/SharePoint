/* SP.JS CAML QUERY BUILDER 1.1.1 */
/* https://github.com/usaalex/SharePoint */
/* © WM-FDH, 2016 */
var SPJS = SPJS || {}; SPJS.Query = function () { "use strict"; function e(e) { this.name = "ArgumentNullException", this.message = "Value can not be null or undefined. Parameter name: " + e, this.stack = (new Error).stack } function t(e, t) { this.name = "ArgumentException", this.message = (t || "Argument exception") + ". Parameter name: " + e, this.stack = (new Error).stack } function n(e) { return "undefined" == typeof e || null === e || "" === e } function r(e) { return "undefined" != typeof e && e instanceof Array ? !e.length : !0 } function i(e) { var t = "Text"; return "string" == typeof e && (t = "Text"), "number" == typeof e && (t = "Number"), "boolean" == typeof e && (t = "Boolean"), "object" == typeof e && e instanceof Date && (t = "DateTime"), t } function l(e) { if (0 === P.length && 3 > e) throw new Error("Comparison operator expected."); if (P[P.length - 1] && P[P.length - 1].elementType < 3 && 3 > e) throw new Error("Comparison operator expected."); if (P[P.length - 1] && P[P.length - 1].elementType > 2 && e > 2) throw new Error("Logical join operator expected.") } function a(t, r, i, a, o) { if (t >= 3) { if (n(r)) throw new e("fieldName"); if (n(i)) throw new e("value") } l(t); var u = !1, c = !1; return "DateTime" === a ? c = !!o : i instanceof Date && "boolean" == typeof a ? (c = !!a, a = "DateTime") : "boolean" == typeof a && (u = !!a, a = t === W.in_ ? u ? "Integer" : "Text" : o ? "LookupMulti" : "Lookup"), P.push(new _(t, r, i, a, u, c)), this } function o() { return a.call(this, W.and) } function u() { return a.call(this, W.or) } function c(e, t, n, r) { return a.call(this, W.eq, e, t, n, r) } function s(e, t, n, r) { return a.call(this, W.neq, e, t, n, r) } function f(e, t, n, r) { return a.call(this, W.gt, e, t, n, r) } function p(e, t, n, r) { return a.call(this, W.geq, e, t, n, r) } function h(e, t, n, r) { return a.call(this, W.lt, e, t, n, r) } function d(e, t, n, r) { return a.call(this, W.leq, e, t, n, r) } function m(e, t, n, r) { return a.call(this, W.begins, e, t, n, r) } function g(e, t, n, r) { return a.call(this, W.contains, e, t, n, r) } function y(e, i, l, o) { if (n(i) || r(i)) throw new t("values", "Value must be an array and have at least one element."); return a.call(this, W.in_, e, i, l, o) } function w(e, t) { return a.call(this, W.isNull, e) } function v(e, t) { return a.call(this, W.isNotNull, e) } function N(t, r) { if (n(t)) throw new e("fieldName"); var r = r ? "TRUE" : "FALSE"; return B = '<GroupBy Collapse = "' + r + '"><FieldRef Name = "' + t + '"/></GroupBy>', this } function T(t, r) { if (n(t)) throw new e("fieldName"); var i = r ? "FALSE" : "TRUE"; return D += '<FieldRef Name="' + t + '" Ascending="' + i + '" />', this } function k(t) { if (n(t) || isNaN(t)) throw new e("num"); return O = +t || 0, this } function b(t) { if (n(t)) throw new e("viewScope"); return M = t, this } function I() { for (var e = "", t = 0; t < arguments.length; t++) "string" == typeof arguments[t] && (e += '<FieldRef Name="' + arguments[t] + '" />'); return G = e, this } function q() { var e = "{caml}"; 0 === P.length && (e = ""); for (var t = 0; t < P.length; t++) switch (P[t].elementType) { case W.and: e = "<And>{caml}{caml}</And>".replace("{caml}", e); break; case W.or: e = "<Or>{caml}{caml}</Or>".replace("{caml}", e); break; case W.eq: e = e.replace("{caml}", "<Eq>" + E(P[t]) + "</Eq>"); break; case W.neq: e = e.replace("{caml}", "<Neq>" + E(P[t]) + "</Neq>"); break; case W.gt: e = e.replace("{caml}", "<Gt>" + E(P[t]) + "</Gt>"); break; case W.geq: e = e.replace("{caml}", "<Geq>" + E(P[t]) + "</Geq>"); break; case W.lt: e = e.replace("{caml}", "<Lt>" + E(P[t]) + "</Lt>"); break; case W.leq: e = e.replace("{caml}", "<Leq>" + E(P[t]) + "</Leq>"); break; case W.begins: e = e.replace("{caml}", "<BeginsWith>" + E(P[t]) + "</BeginsWith>"); break; case W.contains: e = e.replace("{caml}", "<Contains>" + E(P[t]) + "</Contains>"); break; case W.includes: e = e.replace("{caml}", "<Includes>" + E(P[t]) + "</Includes>"); break; case W.notIncludes: e = e.replace("{caml}", "<NotIncludes>" + E(P[t]) + "</NotIncludes>"); break; case W.isNull: e = e.replace("{caml}", '<IsNull><FieldRef Name="' + P[t].field + '" /></IsNull>'); break; case W.isNotNull: e = e.replace("{caml}", '<IsNotNull><FieldRef Name="' + P[t].field + '" /></IsNotNull>'); break; case W.in_: e = e.replace("{caml}", "<In>" + R(P[t]) + "</In>") } return "<Where>" + e + "</Where>" } function E(e) { var t = "", n = ""; return n += "DateTime" === e.valueType ? 'IncludeTimeValue="' + (e.includeTimeValue ? "TRUE" : "FALSE") + '"' : "", t = '<FieldRef Name="' + e.field + '" ' + (e.lookupId ? 'LookupId="TRUE"' : "") + " /><Value " + n + ' Type="' + e.valueType + '">' + e.value + "</Value>" } function L(e, t, n) { var r = "<Query>{where}{order}{group}</Query>".replace("{where}", e || "").replace("{order}", t || "").replace("{group}", n || ""); return r } function S(e, t, n, r) { var i = "<View {scope}>{query}{rowlimit}{fields}</View>".replace("{query}", e || "").replace("{scope}", n || "").replace("{rowlimit}", t || "").replace("{fields}", r || ""); return i } function V(e) { var t = ""; return e > 0 && (t = "<RowLimit>{rowlimit}</RowLimit>".replace("{rowlimit}", e)), t } function C(e) { var t = ""; return e && (t = "<OrderBy>" + e + "</OrderBy>"), t } function F(e) { var t = ""; return e && (t = e), t } function R(e) { var t = "", n = ""; t = '<FieldRef Name="' + e.field + '" ' + (e.lookupId ? 'LookupId="TRUE"' : "") + " /><Values>{values}</Values>"; for (var r = 0; r < e.value.length; r++) n += '<Value Type="' + e.valueType + '">' + e.value[r] + "</Value>"; return t.replace("{values}", n) } function U(e) { var t = ""; return e && (t = "<ViewFields>{fields}</ViewFields>".replace("{fields}", e)), t } function x() { if (P[P.length - 1] && P[P.length - 1].elementType < 3) throw new Error("Comparison operator expected."); var e = q(), t = C(D), n = F(B), r = L(e, t, n), i = V(O), l = U(G), a = S(r, i, M, l); return a } var A = function () { return "1.0.3" }, D = "", B = "", G = "", O = 0, M = "", P = [], W = { and: 1, or: 2, eq: 3, neq: 4, gt: 5, geq: 6, lt: 7, leq: 8, begins: 9, contains: 10, in_: 11, includes: 12, isNull: 13, isNotNull: 14, notIncludes: 15 }; Date.prototype.toISOString || !function () { function e(e) { return 10 > e ? "0" + e : e } Date.prototype.toISOString = function () { return this.getUTCFullYear() + "-" + e(this.getUTCMonth() + 1) + "-" + e(this.getUTCDate()) + "T" + e(this.getUTCHours()) + ":" + e(this.getUTCMinutes()) + ":" + e(this.getUTCSeconds()) + "." + (this.getUTCMilliseconds() / 1e3).toFixed(3).slice(2, 5) + "Z" } }(); var _ = function (e, t, n, r, l, a) { this.elementType = e || 0, this.field = t || "", this.value = n || "", this.valueType = r || "", this.lookupId = !!l, this.includeTimeValue = !!a, t && "undefined" != typeof n && "undefined" == typeof r && (this.valueType = i(n)), t && "undefined" != typeof n && n instanceof Date && (this.value = n.toISOString()), "ID" === t && (this.valueType = "Counter"), "Lookup" != r && "LookupMulti" != r || "undefined" != typeof l || (this.lookupId = !0), "boolean" == typeof n && (this.value = this.value ? 1 : 0) }; return { And: o, Or: u, Eq: c, Neq: s, Gt: f, Geq: p, Lt: h, Leq: d, BeginsWith: m, Contains: g, In: y, IsNull: w, IsNotNull: v, GroupBy: N, OrderBy: T, Scope: b, RowLimit: k, ViewFields: I, build: x, ver: A } };