/* SPRest.Query OData QUERY BUILDER 0.1.0 */
/* https://github.com/usaalex/SharePoint */
/* © WM-FDH, 2016 */
var SPRest = SPRest || {}; SPRest.Query = function (e) { function t(e) { this.name = "ArgumentNullException", this.message = "Value can not be null or undefined. Parameter name: " + e, this.stack = (new Error).stack } function n(e, t) { this.name = "ArgumentException", this.message = (t || "Argument exception") + ". Parameter name: " + e, this.stack = (new Error).stack } function r(e) { return e.filter(function (e, t, n) { return n.indexOf(e) === t }) } function i(e, n, r, i) { if (e != R.and && e != R.or && null == n) throw new t("field"); if (e != R.and && e != R.or && null == r) throw new t("value"); return "boolean" == typeof i && (n = i ? n + "Id" : n + "/Title"), "string" == typeof r ? r = "'" + r + "'" : r instanceof Date ? r = "datetime'" + r.toJSON() + "'" : "boolean" == typeof r && (r = r ? "1" : "0"), e === R.eqx && r instanceof Array ? P = n + " eq '" + r.join("' or " + n + " eq '") + "'" : P += e.replace("{field}", n).replace("{value}", r), j = e, this } function a(e, t, n) { return i.call(this, R.eq, e, t, n) } function l(e, t) { return i.call(this, R.eqx, e, t) } function u(e, t, n) { return i.call(this, R.lt, e, t, n) } function o(e, t, n) { return i.call(this, R.ge, e, t, n) } function s(e, t, n) { return i.call(this, R.gt, e, t, n) } function f(e, t, n) { return i.call(this, R.le, e, t, n) } function c(e, t, n) { return i.call(this, R.ne, e, t, n) } function h(e, t, n) { return i.call(this, R.endswith, e, t, n) } function d(e, t, n) { return i.call(this, R.startswith, e, t, n) } function w(e, t, n) { return i.call(this, R.substringof, e, t, n) } function g() { return i.call(this, R.and) } function m() { return i.call(this, R.or) } function b(e, t) { if (!(e instanceof Array)) throw new n("fields", "Value must be an array."); return V = e || [], k = !!t, this } function v(e) { if (isNaN(+e)) throw new n("count", 'Value must be of type "Number".'); return $ = e || 0, this } function y(e) { if (!(e instanceof Array)) throw new n("fields", "Value must be an array."); return E = e || [], this } function p(e) { if (!(e instanceof Array)) throw new n("fields", "Value must be an array."); return N = N.concat(e || []), this } function q(t) { if (O != S) throw new Error("Parentheses are not balanced."); return N.forEach(function (e) { var t = E.indexOf(e); t > -1 && (E[t] = E[t] + "/Id," + E[t] + "/Title") }), A += e ? e : "", A += t ? "" : "?", A += P ? "&$filter=" + P : "", A += E.length > 0 ? "&$select=" + r(E).join(",") : "", A += N.length > 0 && E.length > 0 ? "&$expand=" + r(N).join(",") : "", A += V.length > 0 ? "&$orderby=" + r(V).join(",") + (k ? " desc" : " asc") : "", A += $ > 0 ? "&$top=" + $ : "" } var x = function () { return "0.1.0" }, A = "", E = [], P = "", N = [], V = [], $ = 0, j = "", k = !1, S = 0, O = 0, R = { eq: "{field} eq {value}", eqx: "{field} eq {value}", lt: "{field} lt {value}", gt: "{field} gt {value}", ge: "{field} ge {value}", le: "{field} le {value}", ne: "{field} ne {value}", endswith: "endswith({field}, '{value}')", startswith: "startswith({field}, '{value}')", substringof: "substringof({field}, '{value}')", and: " and ", or: " or " }; return { eq: a, lt: u, le: f, gt: s, ge: o, ne: c, eqx: l, and: g, or: m, endswith: h, startswith: d, substringof: w, select: y, top: v, orderby: b, expand: p, build: q, ver: x } };